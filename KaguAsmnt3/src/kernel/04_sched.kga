// we should create PCB(process control block)
// PID <pid> NAME <name> STATE <state> PRIORITY <priority> MEM_START <start> MEM_END <end> PC <program counter> FD_LIST <descriptor 1> <descriptor 2> <descriptor 3>

var sys_proc_memory_size
var sys_pcb_list_start
var sys_pcb_list_end
var sys_proc_max_count
var sys_last_used_pid
var sys_cur_pcb_ptr
var sys_pcb_free_mem_list
var sys_sched_time_quantum
var sys_sched_selected_process_multiplier

label sys_interrupt_handler
    // Backup registers to the local variables:
        var sys_int_hndl_reg_op
        copy REG_OP to var:sys_int_hndl_reg_op
        var sys_int_hndl_reg_a
        copy REG_A to var:sys_int_hndl_reg_a
        var sys_int_hndl_reg_b
        copy REG_B to var:sys_int_hndl_reg_b
        var sys_int_hndl_reg_c
        copy REG_C to var:sys_int_hndl_reg_c
        var sys_int_hndl_reg_d
        copy REG_D to var:sys_int_hndl_reg_d
        var sys_int_hndl_reg_res
        copy REG_RES to var:sys_int_hndl_reg_res
        var sys_int_hndl_reg_bool_res
        copy REG_BOOL_RES to var:sys_int_hndl_reg_bool_res
        var sys_int_hndl_reg_error
        copy REG_ERROR to var:sys_int_hndl_reg_error

    // copy values of the registers to the process memory:
        // add 2 to get REG_OP address of process to set a backup
        copy REG_PROC_START_ADDRESS to REG_A
        write 2 to REG_B
        write OP_ADD to REG_OP
        cpu_exec
        copy var:sys_int_hndl_reg_op to *REG_RES

        // add 4 to get REG_A address of process to set a backup
        // copy REG_PROC_START_ADDRESS to REG_A
        write 4 to REG_B
        // write OP_ADD to REG_OP
        cpu_exec
        copy var:sys_int_hndl_reg_a to *REG_RES

        // add 6 to get REG_B address of process to set a backup
        // copy REG_PROC_START_ADDRESS to REG_A
        write 6 to REG_B
        // write OP_ADD to REG_OP
        cpu_exec
        copy var:sys_int_hndl_reg_b to *REG_RES

        // add 8 to get REG_C address of process to set a backup
        // copy REG_PROC_START_ADDRESS to REG_A
        write 8 to REG_B
        // write OP_ADD to REG_OP
        cpu_exec
        copy var:sys_int_hndl_reg_c to *REG_RES

        // add 10 to get REG_D address of process to set a backup
        // copy REG_PROC_START_ADDRESS to REG_A
        write 10 to REG_B
        // write OP_ADD to REG_OP
        cpu_exec
        copy var:sys_int_hndl_reg_d to *REG_RES

        // add 12 to get REG_RES address of process to set a backup
        // copy REG_PROC_START_ADDRESS to REG_A
        write 12 to REG_B
        // write OP_ADD to REG_OP
        cpu_exec
        copy var:sys_int_hndl_reg_res to *REG_RES

        // add 14 to get REG_BOOL_RES address of process to set a backup
        // copy REG_PROC_START_ADDRESS to REG_A
        write 14 to REG_B
        // write OP_ADD to REG_OP
        cpu_exec
        copy var:sys_int_hndl_reg_bool_res to *REG_RES

        // add 16 to get REG_ERROR address of process to set a backup
        // copy REG_PROC_START_ADDRESS to REG_A
        write 16 to REG_B
        // write OP_ADD to REG_OP
        cpu_exec
        copy var:sys_int_hndl_reg_error to *REG_RES

    // Analyze interrupt info and reschedule the processes
        // As of now we support only hardware timer interrupt(code 1) to be handled by this code:
        copy REG_SYS_INTERRUPT_DATA to REG_A
        write 1 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec
        copy REG_RES to REG_A
        // write 1 to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if_not label:kernel_panic

        copy REG_SYS_INTERRUPT_DATA to REG_A
        write 2 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec

        copy *var:sys_cur_pcb_ptr to REG_A
        write 14 to REG_B
        write " " to REG_C
        copy REG_RES to REG_D // set updated program counter to process control block
        write OP_REPLACE_COLUMN to REG_OP
        cpu_exec
        copy REG_RES to *var:sys_cur_pcb_ptr

        jump label:sys_sched_run

label sys_sched_run
    var sys_sched_run_cur_pcb
    write "" to var:sys_sched_run_cur_pcb

    // Let's call an algorithm to find the next process ready for execution
    copy PROGRAM_COUNTER to var:sys_return
    jump label:sys_sched_select_next
    jump_err label:sys_sched_run_no_process
    copy REG_RES to var:sys_cur_pcb_ptr
    copy *var:sys_cur_pcb_ptr to var:sys_sched_run_cur_pcb

    // Parse process control block to set it's address range and program counter to the proper registers:
    // Get memory start address:
    copy var:sys_sched_run_cur_pcb to REG_A
    write 10 to REG_B
    write OP_GET_COLUMN to REG_OP
    cpu_exec
    copy REG_RES to REG_PROC_START_ADDRESS

    // Get memory end address:
    // copy var:sys_sched_run_cur_pcb to REG_A
    write 12 to REG_B
    // write OP_GET_COLUMN to REG_OP
    cpu_exec
    copy REG_RES to REG_PROC_END_ADDRESS

    // Get program counter:
    // copy var:sys_sched_run_cur_pcb to REG_A
    write 14 to REG_B
    // write OP_GET_COLUMN to REG_OP
    cpu_exec
    var sys_sched_run_pc
    copy REG_RES to var:sys_sched_run_pc

    copy REG_SYS_INTERRUPT_DATA to REG_A
    write "" to REG_B
    write OP_CMP_EQ to REG_OP
    cpu_exec
    jump_if_not label:sys_sched_run_adjust_interrupt_data
    write "0 0 1" to REG_SYS_INTERRUPT_DATA // set default interrupt data for further adjustment

    // Let's update interrupt data with new program counter for return address:
    label sys_sched_run_adjust_interrupt_data
        copy REG_SYS_INTERRUPT_DATA to REG_A
        write 2 to REG_B
        write " " to REG_C
        copy var:sys_sched_run_pc to REG_D
        write OP_REPLACE_COLUMN to REG_OP
        cpu_exec
        copy REG_RES to REG_SYS_INTERRUPT_DATA

    // Set the count of ticks for hardware timer to trigger the next interrupt:
    copy var:sys_sched_time_quantum to REG_A
    copy var:sys_sched_selected_process_multiplier to REG_B
    write OP_MUL to REG_OP
    cpu_exec

    copy REG_RES to REG_SYS_HW_TIMER
    write OP_SYS_RETURN to REG_OP
    cpu_exec

    label sys_sched_run_no_process
        // if we didn't find process ready for execution, exit from scheduling
        write "" to var:sys_cur_pcb_ptr
        jump label:kernel_start



// This function allows to find the next process to be executed
// RETURN:
//      REG_RES contains a pointer to the process control block of the next process to be executed
//      REG_ERROR if no process was found for scheduling
label sys_sched_select_next
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    var sys_sched_current_priority
    var sys_sched_found_ptr
    var sys_sched_select_end
    var sys_sched_select_cur_process_id
    var sys_sched_select_other_priority
    var sys_sched_select_other_pid

    // Simulate previously designed ring buffer using two cycles
    // Where 1st cycle goes from current pcb to the end of the list
    // And 2nd cycle goes from the start of the list to the current pcb
    // This ensures all processes are checked and current process is the last one to be checked
    var sys_sched_select_cycle1_start
    var sys_sched_select_cycle1_end
    var sys_sched_select_cycle2_start
    var sys_sched_select_cycle2_end

    // Check if we have current pcb
    copy var:sys_cur_pcb_ptr to REG_A
    write "" to REG_B
    write OP_CMP_EQ to REG_OP
    cpu_exec
    jump_if label:sys_sched_select_next_no_cur_pcb

    // Start from the next pcb after current
    // This will make current pcb the last one to be checked by algorithm
    copy var:sys_cur_pcb_ptr to REG_A
    write OP_INCR to REG_OP
    cpu_exec

    // Initialization of cycle pointers
    copy REG_RES to var:sys_sched_select_cycle1_start
    copy var:sys_pcb_list_end to var:sys_sched_select_cycle1_end
    copy var:sys_pcb_list_start to var:sys_sched_select_cycle2_start
    copy REG_RES to var:sys_sched_select_cycle2_end
    jump label:sys_sched_select_next_cur_pcb_exist

    label sys_sched_select_next_no_cur_pcb
        // No active process, let's start search from the first process control block:
        copy var:sys_pcb_list_start to var:sys_sched_select_cycle1_start
        copy var:sys_pcb_list_end to var:sys_sched_select_cycle1_end
        copy var:sys_pcb_list_start to var:sys_sched_select_cycle2_start
        
        // This will make second cycles size equal to one pcb
        // And also allow us to pass check if this is first or second cycle  
        copy var:sys_pcb_list_start to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_select_cycle2_end
    
    label sys_sched_select_next_cur_pcb_exist
        var sys_sched_group1_ptr
        copy var:sys_sched_select_cycle1_start to var:sys_sched_group1_ptr
        copy var:sys_sched_select_cycle1_end to var:sys_sched_select_end

    // In this loop we look for active processes from first group (priority 0-30)
    label search_group1_loop
        copy *var:sys_sched_group1_ptr to REG_A
        write 6 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec

        copy REG_RES to REG_A
        write "ready" to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if_not label:group1_not_ready

        // Process is ready, let's check its priority
        copy *var:sys_sched_group1_ptr to REG_A
        write 8 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec

        copy REG_RES to REG_A
        write "31" to REG_B
        write OP_CMP_LT to REG_OP
        cpu_exec
        jump_if label:group1_found
    
    // Process is not ready, proceed to the next one
    label group1_not_ready
        copy var:sys_sched_group1_ptr to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_group1_ptr

        copy var:sys_sched_group1_ptr to REG_A
        copy var:sys_sched_select_end to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:search_group1_end
        jump label:search_group1_loop
    
    // We found active process from group 1
    // Now let's find out if it has the highest priority
    label group1_found
        copy var:sys_sched_group1_ptr to var:sys_sched_found_ptr

        copy *var:sys_sched_group1_ptr to REG_A
        write 2 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_select_cur_process_id

        copy *var:sys_sched_group1_ptr to REG_A
        write 8 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_current_priority

        var group1_counter
        var group1_counter_ptr
        write "0" to var:group1_counter
        copy var:sys_pcb_list_start to var:group1_counter_ptr

        // Loop that will iterate through all pcb's
        // Logic inside: We loop for all pcb's from group 1
        // If they have higher priority than current process, we increment counter
        // If counter is zero, then our current process has the highest priority
        // Which means we need to give it x2 multiplier
        label set_multiplier_group_1
            copy *var:group1_counter_ptr to REG_A
            write 6 to REG_B
            write " " to REG_C
            write OP_GET_COLUMN to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            write "ready" to REG_B
            write OP_CMP_EQ to REG_OP
            cpu_exec
            jump_if_not label:set_multiplier_group_1_increment_counter

            // Process is ready, let's check its priority
            copy *var:group1_counter_ptr to REG_A
            write 8 to REG_B
            write " " to REG_C
            write OP_GET_COLUMN to REG_OP
            cpu_exec
            copy REG_RES to var:sys_sched_select_other_priority

            copy var:sys_sched_select_other_priority to REG_A
            write "31" to REG_B
            write OP_CMP_LT to REG_OP
            cpu_exec
            jump_if_not label:set_multiplier_group_1_increment_counter

            copy var:sys_sched_current_priority to REG_A
            copy var:sys_sched_select_other_priority to REG_B
            write OP_CMP_LT to REG_OP
            cpu_exec
            jump_if label:set_multiplier_group_1_increment_counter

            copy var:sys_sched_current_priority to REG_A
            copy var:sys_sched_select_other_priority to REG_B
            write OP_CMP_EQ to REG_OP
            cpu_exec
            jump_if_not label:set_multiplier_group_1_add_counter

            // Our processes has the same priority
            // We need PID for further checks
            copy *var:group1_counter_ptr to REG_A
            write 2 to REG_B
            write " " to REG_C
            write OP_GET_COLUMN to REG_OP
            cpu_exec
            copy REG_RES to var:sys_sched_select_other_pid

            // IF PID < Other PID that it has higher priority
            // This serves as tie-breaker
            copy var:sys_sched_select_cur_process_id to REG_A
            copy var:sys_sched_select_other_pid to REG_B
            write OP_CMP_LT to REG_OP
            cpu_exec
            jump_if label:set_multiplier_group_1_increment_counter

            // IF PID == Other PID that we basically check same process
            copy var:sys_sched_select_cur_process_id to REG_A
            copy var:sys_sched_select_other_pid to REG_B
            write OP_CMP_EQ to REG_OP
            cpu_exec
            jump_if label:set_multiplier_group_1_increment_counter

            label set_multiplier_group_1_add_counter
                copy var:group1_counter to REG_A
                write OP_INCR to REG_OP
                cpu_exec
                copy REG_RES to var:group1_counter

            label set_multiplier_group_1_increment_counter
                copy var:group1_counter_ptr to REG_A
                write OP_INCR to REG_OP
                cpu_exec
                copy REG_RES to var:group1_counter_ptr

                copy var:group1_counter_ptr to REG_A
                copy var:sys_pcb_list_end to REG_B
                write OP_CMP_EQ to REG_OP
                cpu_exec
                jump_if_not label:set_multiplier_group_1

            copy var:group1_counter to REG_A
            write "0" to REG_B
            write OP_CMP_EQ to REG_OP
            cpu_exec
            jump_if label:set_multiplier_2

        write "1" to var:sys_sched_selected_process_multiplier
        jump label:sys_sched_select_next_return
    
    label set_multiplier_2
        write "2" to var:sys_sched_selected_process_multiplier
        jump label:sys_sched_select_next_return
    
    label search_group1_end
        copy var:sys_sched_select_end to REG_A
        copy var:sys_sched_select_cycle1_end to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:search_group1_restore

        var group2_3_ptr
        copy var:sys_sched_select_cycle1_start to var:group2_3_ptr
        copy var:sys_sched_select_cycle1_end to var:sys_sched_select_end
        jump label:search_group2_3_loop

    // Our trick with two cycles
    label search_group1_restore
        copy var:sys_sched_select_cycle2_start to var:sys_sched_group1_ptr
        copy var:sys_sched_select_cycle2_end to var:sys_sched_select_end
        jump label:search_group1_loop
    
    // No processes from group 1 were found, proceed to look in group 2-3 (priority 31-70, 71-100)
    label search_group2_3_loop
        copy *var:group2_3_ptr to REG_A
        write 6 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec

        copy REG_RES to REG_A
        write "ready" to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if_not label:group2_3_not_ready

        copy *var:group2_3_ptr to REG_A
        write 8 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_current_priority

        copy var:sys_sched_current_priority to REG_A
        write "31" to REG_B
        write OP_CMP_LT to REG_OP
        cpu_exec
        jump_if label:group2_3_not_ready

        copy var:sys_sched_current_priority to REG_A
        write "71" to REG_B
        write OP_CMP_LT to REG_OP
        cpu_exec
        jump_if_not label:group3_found

    // Process from group 2 was found, proceed to assign a multiplier
    label group2_found
        copy var:group2_3_ptr to var:sys_sched_found_ptr

        copy *var:group2_3_ptr to REG_A
        write 2 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_select_cur_process_id

        copy *var:group2_3_ptr to REG_A
        write 8 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_current_priority

        var group2_counter
        var group2_counter_ptr
        write "0" to var:group2_counter
        copy var:sys_pcb_list_start to var:group2_counter_ptr

        // Loop that will iterate through all pcb's
        // Here we count number of processes
        // That has lower priority than current process
        // And are inside the same group (31-70)
        // Then we will add 2 to the result and it will be our multiplier
        label set_multiplier_group_2_3
            copy *var:group2_counter_ptr to REG_A
            write 6 to REG_B
            write " " to REG_C
            write OP_GET_COLUMN to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            write "ready" to REG_B
            write OP_CMP_EQ to REG_OP
            cpu_exec
            jump_if_not label:set_multiplier_group_2_3_increment_counter

            copy *var:group2_counter_ptr to REG_A
            write 8 to REG_B
            write " " to REG_C
            write OP_GET_COLUMN to REG_OP
            cpu_exec
            copy REG_RES to var:sys_sched_select_other_priority

            write "30" to REG_A
            copy var:sys_sched_select_other_priority to REG_B
            write OP_CMP_LT to REG_OP
            cpu_exec
            jump_if_not label:set_multiplier_group_2_3_increment_counter

            copy var:sys_sched_select_other_priority to REG_A
            write "71" to REG_B
            write OP_CMP_LT to REG_OP
            cpu_exec
            jump_if_not label:set_multiplier_group_2_3_increment_counter
            // At this point process is from the same group
            copy var:sys_sched_current_priority to REG_A
            copy var:sys_sched_select_other_priority to REG_B
            write OP_CMP_LT to REG_OP
            cpu_exec
            jump_if label:set_multiplier_group_2_3_add_counter

            copy var:sys_sched_current_priority to REG_A
            copy var:sys_sched_select_other_priority to REG_B
            write OP_CMP_EQ to REG_OP
            cpu_exec
            jump_if_not label:set_multiplier_group_2_3_increment_counter
            // At this point process has the same priority
            // Proceed to apply tie-breaker
            copy *var:group2_counter_ptr to REG_A
            write 2 to REG_B
            write " " to REG_C
            write OP_GET_COLUMN to REG_OP
            cpu_exec
            copy REG_RES to var:sys_sched_select_other_pid

            copy var:sys_sched_select_cur_process_id to REG_A
            copy var:sys_sched_select_other_pid to REG_B
            write OP_CMP_LT to REG_OP
            cpu_exec
            jump_if label:set_multiplier_group_2_3_add_counter
            jump label:set_multiplier_group_2_3_increment_counter

            label set_multiplier_group_2_3_add_counter
                copy var:group2_counter to REG_A
                write OP_INCR to REG_OP
                cpu_exec
                copy REG_RES to var:group2_counter

            label set_multiplier_group_2_3_increment_counter
                copy var:group2_counter_ptr to REG_A
                write OP_INCR to REG_OP
                cpu_exec
                copy REG_RES to var:group2_counter_ptr

                copy var:group2_counter_ptr to REG_A
                copy var:sys_pcb_list_end to REG_B
                write OP_CMP_EQ to REG_OP
                cpu_exec
                jump_if_not label:set_multiplier_group_2_3

            copy var:group2_counter to REG_A
            write "2" to REG_B
            write OP_ADD to REG_OP
            cpu_exec
            copy REG_RES to var:sys_sched_selected_process_multiplier
            jump label:sys_sched_select_next_return

    // All processes from group 3 has const multiplier
    label group3_found
        write "1" to var:sys_sched_selected_process_multiplier
        copy var:group2_3_ptr to var:sys_sched_found_ptr
        jump label:sys_sched_select_next_return
    
    label group2_3_not_ready
        copy var:group2_3_ptr to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to var:group2_3_ptr
        
        copy var:group2_3_ptr to REG_A
        copy var:sys_sched_select_end to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:sys_sched_select_next_no_candidate
        jump label:search_group2_3_loop

    // Cycle trick again
    label search_group2_3_restore
        copy var:sys_sched_select_cycle2_start to var:group2_3_ptr
        copy var:sys_sched_select_cycle2_end to var:sys_sched_select_end
        jump label:search_group2_3_loop
    
    label sys_sched_select_next_no_candidate
        copy var:sys_sched_select_end to REG_A
        copy var:sys_sched_select_cycle1_end to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:search_group2_3_restore
        
        // No processes in list are active, proceed to activate paused processes
        copy PROGRAM_COUNTER to var:sys_return
        jump label:sys_sched_pause_to_ready
        jump_err label:sys_sched_found_no
        jump label:sys_sched_select_next_no_cur_pcb

    label sys_sched_found_no
        write "" to REG_RES
        write "No process to schedule" to REG_ERROR
        jump label:sys_stack_pop
    
    label sys_sched_select_next_return
        write "" to REG_ERROR
        copy var:sys_sched_found_ptr to REG_RES
        jump label:sys_stack_pop


label sys_sched_skip_sched
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push
    write 0 to REG_SYS_HW_TIMER
    write "" to REG_RES
    write "" to REG_ERROR
    jump label:sys_stack_pop


label sys_sched_print_all
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    var sys_sched_print_all_ptr
    copy var:sys_pcb_list_start to var:sys_sched_print_all_ptr
    label sys_sched_check_print_all_loop
        // Get state and check whether it is ready:
        copy *var:sys_sched_print_all_ptr to REG_A
        write 6 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec

        copy REG_RES to REG_A
        write "ready" to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:sys_sched_print_all_display

        // copy REG_A to REG_A
        write "pause" to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:sys_sched_print_all_display
        jump label:sys_sched_print_all_increment_counter

        label sys_sched_print_all_display
            copy *var:sys_sched_print_all_ptr to DISPLAY_BUFFER
            write COLOR_CYAN to DISPLAY_COLOR
            write OP_DISPLAY_LN to REG_OP
            cpu_exec

        label sys_sched_print_all_increment_counter
            copy var:sys_sched_print_all_ptr to REG_A
            write OP_INCR to REG_OP
            cpu_exec
            copy REG_RES to var:sys_sched_print_all_ptr

            copy var:sys_sched_print_all_ptr to REG_A
            copy var:sys_pcb_list_end to REG_B
            write OP_CMP_EQ to REG_OP
            cpu_exec
            jump_if label:sys_stack_pop
            jump label:sys_sched_check_print_all_loop

    jump label:sys_stack_pop



label sys_sched_process_load
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    var sys_sched_process_load_args
    copy REG_A to var:sys_sched_process_load_args
    var sys_sched_process_load_priority
    copy REG_B to var:sys_sched_process_load_priority

    var sys_sched_process_load_pcb
    var sys_sched_process_load_mem_start
    var sys_sched_process_load_mem_end
    var sys_sched_process_load_pc

    // Find free PCB
    var sys_sched_process_load_ptr
    copy var:sys_pcb_list_start to var:sys_sched_process_load_ptr
    label sys_sched_load_loop
        // Get state and check whether it is ready:
        copy *var:sys_sched_process_load_ptr to REG_A
        write "0" to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:sys_sched_load_found

        // If not, increment pointer and check whether we have other PCB
        copy var:sys_sched_process_load_ptr to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_process_load_ptr

        copy var:sys_sched_process_load_ptr to REG_A
        copy var:sys_pcb_list_end to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if_not label:sys_sched_load_loop

        write "" to REG_RES
        write "Max process count is reached. Failed to load new process" to REG_ERROR
        jump label:sys_stack_pop


    label sys_sched_load_found
        copy var:sys_sched_process_load_ptr to var:sys_sched_process_load_pcb

    // Set initial program counter:
    write 16 to var:sys_sched_process_load_pc

    // Let's allocate memory for the process:
    copy var:sys_pcb_free_mem_list to REG_A
    write 1 to REG_B
    write " " to REG_C
    write OP_GET_COLUMN to REG_OP
    cpu_exec

    copy REG_RES to REG_A
    write "" to REG_B
    write OP_CMP_EQ to REG_OP
    cpu_exec
    jump_if label:sys_sched_process_load_no_mem_in_pool
    copy REG_A to var:sys_sched_process_load_mem_start

    copy var:sys_pcb_free_mem_list to REG_A
    write 1 to REG_B
    write " " to REG_C
    write "" to REG_D
    write OP_REPLACE_COLUMN to REG_OP
    cpu_exec
    copy REG_RES to var:sys_pcb_free_mem_list
    copy REG_RES to REG_A
    write " " to REG_B
    write OP_STARTS_WITH to REG_OP
    cpu_exec
    jump_if_not label:sys_sched_process_load_free_mem_ok
    copy REG_RES to var:sys_pcb_free_mem_list
    label sys_sched_process_load_free_mem_ok
        jump label:sys_sched_process_load_start_mem_done


    label sys_sched_process_load_no_mem_in_pool
        copy FREE_MEMORY_START to var:sys_sched_process_load_mem_start

        copy var:sys_sched_process_load_mem_start to REG_A
        copy var:sys_proc_memory_size to REG_B
        write OP_ADD to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_process_load_mem_end

        copy FREE_MEMORY_END to REG_A
        copy var:sys_sched_process_load_mem_end to REG_B
        write OP_CMP_LT to REG_OP
        cpu_exec
        jump_if label:sys_sched_process_load_no_RAM

        // Update start of free memory:
        copy var:sys_sched_process_load_mem_end to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to FREE_MEMORY_START

        jump label:sys_sched_process_load_parse_args

    label sys_sched_process_load_no_RAM
        write "" to REG_RES
        write "Can't allocate RAM for the process" to REG_ERROR
        jump label:sys_stack_pop

    label sys_sched_process_load_start_mem_done
        copy var:sys_sched_process_load_mem_start to REG_A
        copy var:sys_proc_memory_size to REG_B
        write OP_ADD to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_process_load_mem_end

    label sys_sched_process_load_parse_args
    // Parse command line into arguments:
    var sys_sched_process_load_arg0
    var sys_sched_process_load_arg1
    var sys_sched_process_load_arg2
    var sys_sched_process_load_arg3

    copy var:sys_sched_process_load_args to REG_A
    copy PROGRAM_COUNTER to var:sys_return
    jump label:sys_remove_unneeded_spaces
    copy REG_RES to var:sys_sched_process_load_args

    copy var:sys_sched_process_load_args to REG_A
    write 1 to REG_B
    write " " to REG_C
    write OP_GET_COLUMN to REG_OP
    cpu_exec
    copy REG_RES to var:sys_sched_process_load_arg0

    // copy var:sys_sched_process_load_args to REG_A
    write 2 to REG_B
    // write " " to REG_C
    // write OP_GET_COLUMN to REG_OP
    cpu_exec
    copy REG_RES to var:sys_sched_process_load_arg1

    // copy var:sys_sched_process_load_args to REG_A
    write 3 to REG_B
    // write " " to REG_C
    // write OP_GET_COLUMN to REG_OP
    cpu_exec
    copy REG_RES to var:sys_sched_process_load_arg2

    // copy var:sys_sched_process_load_args to REG_A
    write 4 to REG_B
    // write " " to REG_C
    // write OP_GET_COLUMN to REG_OP
    cpu_exec
    copy REG_RES to var:sys_sched_process_load_arg3


    // Copy arguments to process space of the process:

    // add 4 to get REG_A address of process and set parameter 1
    copy var:sys_sched_process_load_mem_start to REG_A
    write 4 to REG_B
    write OP_ADD to REG_OP
    cpu_exec
    copy var:sys_sched_process_load_arg1 to *REG_RES

    // add 6 to get REG_B address of process and set parameter 2
    // copy var:sys_sched_process_load_mem_start to REG_A
    write 6 to REG_B
    // write OP_ADD to REG_OP
    cpu_exec
    copy var:sys_sched_process_load_arg2 to *REG_RES

    // add 8 to get REG_C address of process and set parameter 3
    // copy var:sys_sched_process_load_mem_start to REG_A
    write 8 to REG_B
    // write OP_ADD to REG_OP
    cpu_exec
    copy var:sys_sched_process_load_arg3 to *REG_RES

    // add 17 to the start address to get first address for instruction load
    // copy var:sys_sched_process_load_mem_start to REG_A
    write 17 to REG_B
    // write OP_ADD to REG_OP
    cpu_exec
    var sys_sched_process_load_exec_ptr
    copy REG_RES to var:sys_sched_process_load_exec_ptr

    // let's open file:
    var sys_sched_process_load_fd
    copy var:sys_sched_process_load_arg0 to REG_A
    copy PROGRAM_COUNTER to var:sys_return
    jump label:sys_fs_open
    jump_err label:sys_sched_process_load_err
    copy REG_RES to var:sys_sched_process_load_fd

    // Read it line by line:
    var sys_sched_process_load_file_counter
    write 1 to var:sys_sched_process_load_file_counter
    label sys_sched_process_load_file_loop
        copy var:sys_sched_process_load_fd to REG_A
        copy var:sys_sched_process_load_file_counter to REG_B
        copy PROGRAM_COUNTER to var:sys_return
        jump label:sys_fs_read
        jump_err label:sys_sched_process_load_success

        // load to RAM
        copy REG_RES to *var:sys_sched_process_load_exec_ptr
        copy var:sys_sched_process_load_exec_ptr to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_process_load_exec_ptr

        copy var:sys_sched_process_load_file_counter to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_process_load_file_counter

        copy var:sys_sched_process_load_mem_end to REG_A
        copy var:sys_sched_process_load_exec_ptr to REG_B
        write OP_CMP_LT to REG_OP
        cpu_exec
        jump_if label:sys_sched_process_load_no_memory

        jump label:sys_sched_process_load_file_loop

    label sys_sched_process_load_no_memory
        copy var:sys_sched_process_load_fd to REG_A
        copy PROGRAM_COUNTER to var:sys_return
        jump label:sys_fs_close
        write "" to REG_RES
        write "Program is too big to load the program. Change proc_memory in /config.txt and restart the system." to REG_ERROR
        jump label:sys_stack_pop


    label sys_sched_process_load_success
        copy var:sys_sched_process_load_fd to REG_A
        copy PROGRAM_COUNTER to var:sys_return
        jump label:sys_fs_close

        // Let's write meta information about free memory range to the start of memory
        write 17 to REG_A
        copy var:sys_sched_process_load_file_counter to REG_B
        write OP_ADD to REG_OP
        cpu_exec
        var sys_sched_process_load_free_start
        copy REG_RES to var:sys_sched_process_load_free_start

        copy var:sys_last_used_pid to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to var:sys_last_used_pid

        // Prepare process control block
            write "PID" to REG_A
            copy var:sys_last_used_pid to REG_B
            write " " to REG_C
            write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            write "NAME" to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            copy var:sys_sched_process_load_arg0 to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec
            copy REG_RES to REG_A
            copy var:sys_sched_process_load_arg1 to REG_B
            write "|" to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec
            copy REG_RES to REG_A
            copy var:sys_sched_process_load_arg2 to REG_B
            // write "|" to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec
            copy var:sys_sched_process_load_arg3 to REG_B
            // write "|" to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            write "STATE ready" to REG_B
            write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            write "PRIORITY" to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            copy var:sys_sched_process_load_priority to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            write "MEM_START" to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            copy var:sys_sched_process_load_mem_start to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            write "MEM_END" to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            copy var:sys_sched_process_load_mem_end to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            write "PC" to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            copy var:sys_sched_process_load_pc to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            write "FD_LIST" to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to *var:sys_sched_process_load_pcb

        // Prepare meta info for process address space:
            // Append PID
            write "PID" to REG_A
            copy var:sys_last_used_pid to REG_B
            write " " to REG_C
            write OP_CONCAT_WITH to REG_OP
            cpu_exec

            // Append free memory start
            copy REG_RES to REG_A
            write "FREE" to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to REG_A
            copy var:sys_sched_process_load_free_start to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            // Append free memory end:
            copy REG_RES to REG_A
            copy var:sys_proc_memory_size to REG_B
            // write " " to REG_C
            // write OP_CONCAT_WITH to REG_OP
            cpu_exec

            copy REG_RES to *var:sys_sched_process_load_mem_start

        copy var:sys_last_used_pid to REG_RES
        jump label:sys_stack_pop

    label sys_sched_process_load_err
        write "" to REG_RES
        write "Failed to execute command" to REG_ERROR
        jump label:sys_stack_pop


label sys_sched_process_stop
    // Let's clean the memory
    copy var:sys_cur_pcb_ptr to REG_A
    copy PROGRAM_COUNTER to var:sys_return
    jump label:sys_sched_clean_pcb

    write "" to REG_PROC_START_ADDRESS
    write "" to REG_PROC_END_ADDRESS
    write "" to var:sys_cur_pcb_ptr

    jump label:sys_sched_run



label sys_sched_process_add_fd
    // input REG_A = fd
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    copy REG_A to REG_B
    copy *var:sys_cur_pcb_ptr to REG_A
    write " " to REG_C
    write OP_CONCAT_WITH to REG_OP
    cpu_exec
    copy REG_RES to *var:sys_cur_pcb_ptr

    jump label:sys_stack_pop



label sys_sched_process_rm_fd
    // input REG_A = fd
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    var sys_sched_process_rm_fd_value
    copy REG_A to var:sys_sched_process_rm_fd_value

    var sys_sched_process_rm_fd_counter
    write 16 to var:sys_sched_process_rm_fd_counter
    label sys_sched_process_rm_fd_loop
        copy *var:sys_cur_pcb_ptr to REG_A
        copy var:sys_sched_process_rm_fd_counter to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec

        copy REG_RES to REG_A
        copy var:sys_sched_process_rm_fd_value to REG_C
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:sys_sched_process_rm_fd_found

        // copy REG_A to REG_A
        write "" to REG_B
        // write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:sys_sched_process_rm_fd_not_found

        copy var:sys_sched_process_rm_fd_counter to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_process_rm_fd_counter

        jump label:sys_sched_process_rm_fd_loop

    label sys_sched_process_rm_fd_found
        copy *var:sys_cur_pcb_ptr to REG_A
        copy var:sys_sched_process_rm_fd_counter to REG_B
        write " " to REG_C
        write "" to REG_D
        write OP_REPLACE_COLUMN to REG_OP
        cpu_exec

        copy REG_RES to REG_A
        copy PROGRAM_COUNTER to var:sys_return
        jump label:sys_remove_unneeded_spaces

        copy REG_RES to *var:sys_cur_pcb_ptr
        jump label:sys_stack_pop

    label sys_sched_process_rm_fd_not_found
        jump label:sys_stack_pop

label sys_remove_unneeded_spaces
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    // REG_A contains the input string for cleanup so we can use it directly from register
    write OP_STARTS_WITH to REG_OP
    write " " to REG_B
    label sys_remove_unneeded_spaces_leading
        // copy REG_A to REG_A
        // write OP_STARTS_WITH to REG_OP
        // write " " to REG_B
        cpu_exec
        jump_if_not label:sys_remove_unneeded_spaces_duplicated

        copy REG_RES to REG_A
        jump label:sys_remove_unneeded_spaces_leading

    // Now we should remove duplicated spaces
    label sys_remove_unneeded_spaces_duplicated
        // copy REG_A to REG_A
        write "  " to REG_B
        write OP_CONTAINS to REG_OP
        cpu_exec
        jump_if_not label:sys_remove_unneeded_spaces_done

        // copy REG_A to REG_A
        copy REG_RES to REG_B
        write " " to REG_C
        write "" to REG_D
        write OP_REPLACE_COLUMN to REG_OP
        cpu_exec
        copy REG_RES to REG_A

        jump label:sys_remove_unneeded_spaces_duplicated

    label sys_remove_unneeded_spaces_done
        copy REG_A to REG_RES
        jump label:sys_stack_pop



// Input: REG_A - pid of the process
// RESULT: REG_RES address of process control block for PID, RES_ERROR set if not found
label sys_sched_pid_to_pcb
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    var sys_sched_pid_to_pcb_PID
    copy REG_A to var:sys_sched_pid_to_pcb_PID

    var sys_sched_pid_to_pcb_ptr
    copy var:sys_pcb_list_start to var:sys_sched_pid_to_pcb_ptr
    label sys_sched_pid_to_pcb_loop
        copy *var:sys_sched_pid_to_pcb_ptr to REG_A
        write 2 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec

        copy REG_RES to REG_A
        copy var:sys_sched_pid_to_pcb_PID to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:sys_sched_pid_to_pcb_found

        copy var:sys_sched_pid_to_pcb_ptr to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_pid_to_pcb_ptr

        copy var:sys_sched_pid_to_pcb_ptr to REG_A
        copy var:sys_pcb_list_end to REG_B
        write OP_CMP_LT to REG_OP
        cpu_exec
        jump_if label:sys_sched_pid_to_pcb_loop

    // If no process with PID found let's return an error
    write "" to REG_RES
    write "No active process with provided PID found" to REG_ERROR
    jump label:sys_stack_pop

    label sys_sched_pid_to_pcb_found
        copy var:sys_sched_pid_to_pcb_ptr to REG_RES
        write "" to REG_ERROR
        jump label:sys_stack_pop




label sys_sched_is_active_pid
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    // copy REG_A to REG_A
    copy PROGRAM_COUNTER to var:sys_return
    jump label:sys_sched_pid_to_pcb
    jump_err label:sys_sched_is_active_not_found

    copy *REG_RES to REG_RES
    write "" to REG_ERROR
    jump label:sys_stack_pop

    // If no process with PID found let's return an error
    label sys_sched_is_active_not_found
        write "" to REG_RES
        write "No active process with provided PID found" to REG_ERROR
        jump label:sys_stack_pop




// The main purpose of this function to allow the current process to postpone its own execution
label sys_sched_wait_sched
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    copy var:sys_cur_pcb_ptr to REG_A
    write "" to REG_B
    write OP_CMP_EQ to REG_OP
    cpu_exec
    jump_if label:sys_sched_wait_sched_error

    copy *var:sys_cur_pcb_ptr  to REG_A
    write 6 to REG_B
    write " " to REG_C
    write "pause" to REG_D
    write OP_REPLACE_COLUMN to REG_OP
    cpu_exec
    copy REG_RES to *var:sys_cur_pcb_ptr

    // Let's skip further execution of this process
    copy PROGRAM_COUNTER to var:sys_return
    jump label:sys_sched_skip_sched
    jump label:sys_stack_pop

    label sys_sched_wait_sched_error
        write "" to REG_RES
        write "Something wrong happened. No way to pause the process." to REG_ERROR
        jump label:sys_stack_pop



label sys_sched_pause_to_ready
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    var sys_sched_pause_to_ready_error
    write "Not found process with pause state" to var:sys_sched_pause_to_ready_error

    var sys_sched_pause_to_ready_ptr
    copy var:sys_pcb_list_start to var:sys_sched_pause_to_ready_ptr
    label sys_sched_pause_to_ready_loop
        copy *var:sys_sched_pause_to_ready_ptr to REG_A
        write 6 to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec

        copy REG_RES to REG_A
        write "pause" to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if_not label:sys_sched_pause_to_ready_proceed

        // If we fouund at least one paused process, reset error
        write "" to var:sys_sched_pause_to_ready_error

        copy *var:sys_sched_pause_to_ready_ptr  to REG_A
        write 6 to REG_B
        write " " to REG_C
        write "ready" to REG_D
        write OP_REPLACE_COLUMN to REG_OP
        cpu_exec
        copy REG_RES to *var:sys_sched_pause_to_ready_ptr

        label sys_sched_pause_to_ready_proceed
            copy var:sys_sched_pause_to_ready_ptr to REG_A
            write OP_INCR to REG_OP
            cpu_exec
            copy REG_RES to var:sys_sched_pause_to_ready_ptr

            copy var:sys_sched_pause_to_ready_ptr to REG_A
            copy var:sys_pcb_list_end to REG_B
            write OP_CMP_LT to REG_OP
            cpu_exec
            jump_if label:sys_sched_pause_to_ready_loop

    write "" to REG_RES
    copy var:sys_sched_pause_to_ready_error to REG_ERROR
    jump label:sys_stack_pop

label sys_sched_kill_pid
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    // copy REG_A to REG_A
    copy PROGRAM_COUNTER to var:sys_return
    jump label:sys_sched_pid_to_pcb
    jump_err label:sys_sched_kill_pid_not_found

    var sys_sched_kill_pid_pcb
    copy REG_RES to var:sys_sched_kill_pid_pcb

    copy var:sys_sched_kill_pid_pcb to REG_A
    copy var:sys_cur_pcb_ptr to REG_B
    write OP_CMP_EQ to REG_OP
    cpu_exec
    jump_if label:sys_sched_kill_pid_current

    copy REG_RES to REG_A
    copy PROGRAM_COUNTER to var:sys_return
    jump label:sys_sched_clean_pcb
    write "" to REG_RES
    write "" to REG_ERROR
    jump label:sys_stack_pop

    label sys_sched_kill_pid_not_found
        write "" to REG_RES
        write "No active process with provided PID found" to REG_ERROR
        jump label:sys_stack_pop

    label sys_sched_kill_pid_current
        write "" to REG_RES
        write "Process can not use kill PID for its own PID" to REG_ERROR
        jump label:sys_stack_pop



// Function to clean process control block together with the process memory
// Input: REG_A - address of process control block
label sys_sched_clean_pcb
    copy PROGRAM_COUNTER to var:sys_stack_return
    jump label:sys_stack_push

    var sys_sched_clean_pcb_ptr
    copy REG_A to var:sys_sched_clean_pcb_ptr

    var sys_sched_clean_pcb_start_mem
    copy *var:sys_sched_clean_pcb_ptr to REG_A
    write 10 to REG_B
    write " " to REG_C
    write OP_GET_COLUMN to REG_OP
    cpu_exec
    copy REG_RES to var:sys_sched_clean_pcb_start_mem

    var sys_sched_clean_pcb_end_mem
    // copy *var:sys_sched_clean_pcb_ptr to REG_A
    write 12 to REG_B
    // write " " to REG_C
    // write OP_GET_COLUMN to REG_OP
    cpu_exec
    copy REG_RES to var:sys_sched_clean_pcb_end_mem

    copy var:sys_sched_clean_pcb_start_mem to REG_A
    copy var:sys_sched_clean_pcb_end_mem to REG_B
    label sys_sched_clean_pcb_loop
        write "" to *REG_A

        // Increment pointer in REG_A
        // address that was just cleaned is already in REG_A
        write OP_INCR to REG_OP
        cpu_exec

        // check whether it is still <= REG_PROC_END_ADDRESS
        copy REG_RES to REG_A
        // copy REG_PROC_END_ADDRESS to REG_B
        write OP_CMP_LT to REG_OP
        cpu_exec
        jump_if label:sys_sched_clean_pcb_loop

    // File descriptors cleanup
    var sys_sched_clean_pcb_cur_pcb
    var sys_sched_clean_pcb_counter
    copy *var:sys_sched_clean_pcb_ptr to var:sys_sched_clean_pcb_cur_pcb
    write 16 to var:sys_sched_clean_pcb_counter
    label sys_sched_clean_pcb_fd_loop
        copy var:sys_sched_clean_pcb_cur_pcb to REG_A
        copy var:sys_sched_clean_pcb_counter to REG_B
        write " " to REG_C
        write OP_GET_COLUMN to REG_OP
        cpu_exec

        copy REG_RES to REG_A
        write "" to REG_B
        write OP_CMP_EQ to REG_OP
        cpu_exec
        jump_if label:sys_sched_clean_pcb_finalize

        // copy REG_RES to REG_A
        copy PROGRAM_COUNTER to var:sys_return
        jump label:sys_fs_close

        copy var:sys_sched_clean_pcb_counter to REG_A
        write OP_INCR to REG_OP
        cpu_exec
        copy REG_RES to var:sys_sched_clean_pcb_counter

        jump label:sys_sched_clean_pcb_fd_loop

    label sys_sched_clean_pcb_finalize
        // let's mark the memory from the process as free for further reuse
        copy var:sys_sched_clean_pcb_start_mem to REG_A
        copy var:sys_pcb_free_mem_list to REG_B
        write " " to REG_C
        write OP_CONCAT_WITH to REG_OP
        cpu_exec
        copy REG_RES to var:sys_pcb_free_mem_list

        write "0" to *var:sys_sched_clean_pcb_ptr
        write "" to REG_RES
        write "" to REG_ERROR
        jump label:sys_stack_pop